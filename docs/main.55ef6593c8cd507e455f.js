!function(e){var r={};function n(t){if(r[t])return r[t].exports;var o=r[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=r,n.d=function(e,r,t){n.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,r){if(1&r&&(e=n(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var o in e)n.d(t,o,function(r){return e[r]}.bind(null,o));return t},n.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(r,"a",r),r},n.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},n.p="",n(n.s=1)}([function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/index.scss?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/tools/locate.ts\nconst locate = (el) => {\r\n    const coordinates = ['x', 'y']\r\n        .map(c => el.getAttribute(c))\r\n        .map(c => parseInt(c));\r\n    return coordinates;\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/move.ts\n\r\nconst move = (el, [x, y]) => {\r\n    const [currentX, currentY] = locate(el);\r\n    if (currentX !== x) {\r\n        el.setAttribute('x', `${x}`);\r\n    }\r\n    if (currentY !== y) {\r\n        el.setAttribute('y', `${y}`);\r\n    }\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/invokeRepeatedly.ts\nconst invokeRepeatedly = (f, times) => {\r\n    for (let index = 0; index < times; index++) {\r\n        f();\r\n    }\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/randomizeInt.ts\nconst randomizeInt = n => Math.floor(Math.random() * n);\r\n\n// CONCATENATED MODULE: ./src/decorators/eventHandler.ts\nfunction eventHandler(eventName) {\r\n    return function _decorator(target, propKey, descriptor) {\r\n        if (!target.connectedCallback) {\r\n            target.connectedCallback = function () { };\r\n        }\r\n        const connectedDescriptor = Object.getOwnPropertyDescriptor(target, 'connectedCallback') ||\r\n            Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), 'connectedCallback');\r\n        const originalConnectedCallback = connectedDescriptor.value;\r\n        const connectedDecoration = function () {\r\n            originalConnectedCallback.bind(this)();\r\n            this.addEventListener(eventName, this[propKey].bind(this));\r\n        };\r\n        connectedDecoration.bind(target);\r\n        Object.defineProperty(target, 'connectedCallback', Object.assign({}, connectedDescriptor, { value: connectedDecoration }));\r\n        return descriptor;\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/components/unit-edible.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\n\r\nclass UnitEdible extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n    }\r\n    static construct() {\r\n        const instance = document.createElement('unit-edible');\r\n        return {\r\n            appendTo: (el) => {\r\n                el.appendChild(instance);\r\n                return instance;\r\n            }\r\n        };\r\n    }\r\n    spoil() {\r\n        this.setAttribute('life', '-1');\r\n    }\r\n    dontFollowHorribleHTML5Spec(ev) {\r\n        ev.preventDefault();\r\n    }\r\n    removeSelf(ev) {\r\n        if (ev.detail.receiver === this) {\r\n            this.parentElement.removeChild(this);\r\n        }\r\n    }\r\n}\r\n__decorate([\r\n    eventHandler('dragstart'),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], UnitEdible.prototype, \"dontFollowHorribleHTML5Spec\", null);\r\n__decorate([\r\n    eventHandler('collision'),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], UnitEdible.prototype, \"removeSelf\", null);\r\n// const edible = document.createElement('unit-edible') as HTMLElement;\r\n// edible.setAttribute('life', '1');\r\n// move(edible, this.randomCoords);\r\n// this.appendChild(edible);\r\n\n// CONCATENATED MODULE: ./src/game.ts\n\r\n\r\n\r\n\r\nconst game = () => {\r\n    let gameIsOver = false;\r\n    const edibleRemovalBaseInterval = 20000;\r\n    const loopBaseInterval = 2000;\r\n    const maxEdiblesPercent = 0.6;\r\n    const ediblesSpawnedBase = 4;\r\n    const hexGrid = document.querySelector('hex-grid');\r\n    const player = document.querySelector('unit-player');\r\n    const spawnSomeEdibles = () => {\r\n        const spawn = () => {\r\n            const instance = UnitEdible.construct().appendTo(hexGrid);\r\n            instance.setAttribute('life', '2');\r\n            const coordinates = hexGrid.randomVacantCoords;\r\n            instance.setAttribute('x', `${coordinates[0]}`);\r\n            instance.setAttribute('y', `${coordinates[1]}`);\r\n            setTimeout(() => instance.spoil(), edibleRemovalBaseInterval);\r\n        };\r\n        const n = randomizeInt(ediblesSpawnedBase);\r\n        invokeRepeatedly(spawn, n);\r\n    };\r\n    const gameOver = () => {\r\n        gameIsOver = true;\r\n        document.body.innerHTML = 'game over';\r\n    };\r\n    const gameStart = () => {\r\n        move(player, hexGrid.randomVacantCoords);\r\n        hexGrid.addEventListener('movement', subtractPlayerLife);\r\n        gameLoop();\r\n    };\r\n    const gameLoop = () => {\r\n        if (gameIsOver) {\r\n            return;\r\n        }\r\n        else {\r\n            turnRoutine();\r\n            setTimeout(gameLoop, randomizeInt(loopBaseInterval));\r\n        }\r\n    };\r\n    const subtractPlayerLife = () => {\r\n        const currentLife = parseInt(player.getAttribute('life'));\r\n        if (currentLife === 1) {\r\n            gameOver();\r\n        }\r\n        else {\r\n            player.setAttribute('life', `${currentLife - 1}`);\r\n        }\r\n    };\r\n    const turnRoutine = () => {\r\n        const currentEdiblesPercent = (hexGrid.ediblesCount / hexGrid.totalSize);\r\n        const ediblesOverflow = currentEdiblesPercent > maxEdiblesPercent;\r\n        if (ediblesOverflow) {\r\n            gameOver();\r\n        }\r\n        else {\r\n            spawnSomeEdibles();\r\n        }\r\n    };\r\n    return gameStart;\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/misc.ts\nconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\r\nconst range = n => {\r\n    if (typeof n === 'string') {\r\n        return [...Array(parseInt(n)).keys()];\r\n    }\r\n    else {\r\n        return [...Array(n).keys()];\r\n    }\r\n};\r\nconst permuteCoords = (x, y) => {\r\n    const res = [];\r\n    for (const xx of range(x)) {\r\n        for (const yy of range(y)) {\r\n            res.push([xx, yy]);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/childElements.ts\nconst childElements = (collection) => {\r\n    const arr = [];\r\n    for (let i = 0; i < collection.length; i++) {\r\n        const el = collection[i];\r\n        if (el instanceof HTMLElement) {\r\n            arr.push(el);\r\n        }\r\n    }\r\n    return arr;\r\n};\r\n\n// CONCATENATED MODULE: ./src/tools/isInRange.ts\n/* tslint:disable */\r\nconst isInRange = (from, to, rangeOfMovement) => {\r\n    const qfrom = offsetToCube(from);\r\n    const qto = offsetToCube(to);\r\n    const distance = cubeDistance(qfrom, qto);\r\n    const satisfiesRange = distance <= rangeOfMovement;\r\n    return satisfiesRange;\r\n};\r\nconst offsetToCube = ([x, y]) => {\r\n    const qx = x - (y - (y & 1)) / 2;\r\n    const qz = y;\r\n    const qy = -qx - qz;\r\n    return [qx, qy, qz];\r\n};\r\nconst cubeDistance = (from, to) => {\r\n    const x = Math.abs(from[0] - to[0]);\r\n    const y = Math.abs(from[1] - to[1]);\r\n    const z = Math.abs(from[2] - to[2]);\r\n    return (x + y + z) / 2;\r\n};\r\n\n// CONCATENATED MODULE: ./src/components/hex-tile.ts\nvar hex_tile_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar hex_tile_metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\n\r\nclass HexTile extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n    }\r\n    dontFollowHorribleHTML5Spec(ev) {\r\n        ev.preventDefault();\r\n    }\r\n    logCoords(ev) {\r\n        console.log(this.getAttribute('x'), this.getAttribute('y'));\r\n    }\r\n}\r\nhex_tile_decorate([\r\n    eventHandler('dragstart'),\r\n    hex_tile_metadata(\"design:type\", Function),\r\n    hex_tile_metadata(\"design:paramtypes\", [Object]),\r\n    hex_tile_metadata(\"design:returntype\", void 0)\r\n], HexTile.prototype, \"dontFollowHorribleHTML5Spec\", null);\r\nhex_tile_decorate([\r\n    eventHandler('click'),\r\n    hex_tile_metadata(\"design:type\", Function),\r\n    hex_tile_metadata(\"design:paramtypes\", [Object]),\r\n    hex_tile_metadata(\"design:returntype\", void 0)\r\n], HexTile.prototype, \"logCoords\", null);\r\n\n// CONCATENATED MODULE: ./src/decorators/childrenAttributeObserver.ts\nfunction childrenAttributeObserver(...attributeNames) {\r\n    return function _decorator(target, propKey, descriptor) {\r\n        const connectedDescriptor = Object.getOwnPropertyDescriptor(target, 'connectedCallback');\r\n        const callbackToDecorate = connectedDescriptor.value;\r\n        const connectedDecoration = function () {\r\n            callbackToDecorate.bind(this)();\r\n            const ob = new MutationObserver(descriptor.value.bind(this));\r\n            const options = {\r\n                attributes: true,\r\n                subtree: true,\r\n                attributeFilter: attributeNames\r\n            };\r\n            ob.observe(this, options);\r\n        };\r\n        connectedDecoration.bind(target);\r\n        Object.defineProperty(target, 'connectedCallback', Object.assign({}, connectedDescriptor, { value: connectedDecoration }));\r\n        return descriptor;\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/meta/HTMLElementPlus.ts\nclass HTMLElementPlus extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n    }\r\n    connectedCallback() {\r\n        const self = this;\r\n        if (self.connected instanceof Function) {\r\n            self.connected();\r\n        }\r\n        if (self.render instanceof Function) {\r\n            self.innerHTML += self.render();\r\n        }\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./src/components/unit-player.ts\nvar unit_player_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar unit_player_metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\n\r\nclass UnitPlayer extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n    }\r\n    eat(ev) {\r\n        const lifeToAdd = ev.detail.receiver.getAttribute('life');\r\n        const newLife = parseInt(this.getAttribute('life')) + parseInt(lifeToAdd);\r\n        this.setAttribute('life', `${newLife}`);\r\n    }\r\n    dontFollowHorribleHTML5Spec(ev) {\r\n        ev.preventDefault();\r\n    }\r\n}\r\nunit_player_decorate([\r\n    eventHandler('collision'),\r\n    unit_player_metadata(\"design:type\", Function),\r\n    unit_player_metadata(\"design:paramtypes\", [Object]),\r\n    unit_player_metadata(\"design:returntype\", void 0)\r\n], UnitPlayer.prototype, \"eat\", null);\r\nunit_player_decorate([\r\n    eventHandler('dragstart'),\r\n    unit_player_metadata(\"design:type\", Function),\r\n    unit_player_metadata(\"design:paramtypes\", [Object]),\r\n    unit_player_metadata(\"design:returntype\", void 0)\r\n], UnitPlayer.prototype, \"dontFollowHorribleHTML5Spec\", null);\r\n\n// CONCATENATED MODULE: ./src/components/hex-grid.ts\nvar hex_grid_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar hex_grid_metadata = (undefined && undefined.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass hex_grid_HexGrid extends HTMLElementPlus {\r\n    constructor() {\r\n        super();\r\n        this.abortDrag = () => {\r\n            if (this.draggedItem) {\r\n                this.draggedItem = null;\r\n            }\r\n        };\r\n    }\r\n    render() {\r\n        const tile = ([x, y]) => `<hex-tile x=${x} y=${y}></hex-tile>`;\r\n        const z = permuteCoords(this.getAttribute('sizex'), this.getAttribute('sizey')).map(tile);\r\n        return z.join('');\r\n    }\r\n    queryIndexExh([x, y]) {\r\n        const h = (el) => {\r\n            const xMatch = el.getAttribute('x') === `${x}`;\r\n            const yMatch = el.getAttribute('y') === `${y}`;\r\n            const notTile = !(el instanceof HexTile);\r\n            return xMatch && yMatch && notTile;\r\n        };\r\n        const occupants = childElements(this.children).filter(h);\r\n        return occupants;\r\n    }\r\n    queryIndex([x, y]) {\r\n        return this.queryIndexExh([x, y])[0];\r\n    }\r\n    dontFollowHorribleHTML5Spec(ev) {\r\n        ev.preventDefault();\r\n    }\r\n    handleMovement(mut) {\r\n        const observedTarget = mut[0].target;\r\n        if (observedTarget instanceof HTMLElement) {\r\n            this.fireMovementEvent();\r\n            ///\r\n            const coordinates = locate(observedTarget);\r\n            const elementAtSameTile = this.queryIndexExh(coordinates)\r\n                .filter(el => el !== observedTarget)[0];\r\n            if (elementAtSameTile) {\r\n                this.fireCollisionEvent(observedTarget, elementAtSameTile);\r\n            }\r\n        }\r\n    }\r\n    fireMovementEvent() {\r\n        const movement = new CustomEvent('movement');\r\n        this.dispatchEvent(movement);\r\n    }\r\n    fireCollisionEvent(issuer, receiver) {\r\n        const childrenCollision = new CustomEvent('collision', {\r\n            bubbles: false,\r\n            detail: { receiver, issuer }\r\n        });\r\n        issuer.dispatchEvent(childrenCollision);\r\n        receiver.dispatchEvent(childrenCollision);\r\n        this.dispatchEvent(childrenCollision);\r\n    }\r\n    moveDraggedItem(ev) {\r\n        if (this.draggedItem) {\r\n            this.draggedItem.classList.add('drag-move');\r\n            this.draggedItem.classList.remove('drag-start');\r\n            this.draggedItem.style.setProperty('--pageXDrag', `${ev.pageX}px`);\r\n            this.draggedItem.style.setProperty('--pageYDrag', `${ev.pageY}px`);\r\n        }\r\n    }\r\n    startDraggingItem(ev) {\r\n        const coordinates = this.pointerPositionToCoords(ev.clientX, ev.clientY);\r\n        const el = this.queryIndex(coordinates);\r\n        if (el instanceof UnitPlayer) {\r\n            el.style.setProperty('--pageXDragOrigin', `${ev.pageX}px`);\r\n            el.style.setProperty('--pageYDragOrigin', `${ev.pageY}px`);\r\n            this.draggedItem = el;\r\n        }\r\n    }\r\n    releaseDraggedItem(ev) {\r\n        const to = this.pointerPositionToCoords(ev.clientX, ev.clientY);\r\n        if (to[0] != null && this.draggedItem) {\r\n            const rangeOfMovement = parseInt(this.draggedItem.getAttribute('rom'));\r\n            const from = locate(this.draggedItem);\r\n            const satisfiesRange = isInRange(from, to, rangeOfMovement);\r\n            if (satisfiesRange) {\r\n                move(this.draggedItem, to);\r\n            }\r\n        }\r\n        this.abortDrag();\r\n    }\r\n    pointerPositionToCoords(pointerX, pointerY) {\r\n        const elements = document.elementsFromPoint(pointerX, pointerY);\r\n        const tile = elements.find(el => el instanceof HexTile);\r\n        if (tile instanceof HexTile) {\r\n            return locate(tile);\r\n        }\r\n        else {\r\n            return [null, null];\r\n        }\r\n    }\r\n    get draggedItem() {\r\n        const el = this.querySelector('.drag');\r\n        return el;\r\n    }\r\n    set draggedItem(candidate) {\r\n        const reference = this.draggedItem;\r\n        if (reference) {\r\n            reference.style.setProperty('--pageXDrag', `${0}px`);\r\n            reference.style.setProperty('--pageYDrag', `${0}px`);\r\n            this.draggedItem.style.setProperty('--pageXDragOrigin', `${0}px`);\r\n            this.draggedItem.style.setProperty('--pageYDragOrigin', `${0}px`);\r\n            reference.classList.remove('drag-move', 'drag-start', 'drag');\r\n            this.tiles.forEach(tile => tile.classList.remove('in-range'));\r\n        }\r\n        if (candidate) {\r\n            candidate.classList.add('drag', 'drag-start');\r\n            const rangeOfMovement = parseInt(candidate.getAttribute('rom'));\r\n            const from = locate(candidate);\r\n            const h = to => isInRange(from, to, rangeOfMovement);\r\n            this.tiles.forEach(tile => {\r\n                if (h(locate(tile))) {\r\n                    tile.classList.add('in-range');\r\n                }\r\n            });\r\n        }\r\n    }\r\n    get tiles() {\r\n        const tiles = childElements(this.children)\r\n            .filter(el => el instanceof HexTile);\r\n        return tiles;\r\n    }\r\n    get randomVacantCoords() {\r\n        const gen = () => ['sizex', 'sizey']\r\n            .map(n => this.getAttribute(n))\r\n            .map(a => parseInt(a))\r\n            .map(b => Math.random() * b)\r\n            .map(c => Math.floor(c));\r\n        const cs = gen();\r\n        const occupied = !!this.queryIndex(cs);\r\n        if (occupied) {\r\n            return this.randomVacantCoords;\r\n        }\r\n        else {\r\n            return cs;\r\n        }\r\n    }\r\n    get ediblesCount() {\r\n        return childElements(this.children)\r\n            .filter(x => x instanceof UnitEdible)\r\n            .length;\r\n    }\r\n    get totalSize() {\r\n        return ['sizex', 'sizey']\r\n            .map(n => this.getAttribute(n))\r\n            .map(a => parseInt(a))\r\n            .reduce((a, x) => a * x, 1);\r\n    }\r\n}\r\nhex_grid_decorate([\r\n    eventHandler('dragstart'),\r\n    hex_grid_metadata(\"design:type\", Function),\r\n    hex_grid_metadata(\"design:paramtypes\", [Object]),\r\n    hex_grid_metadata(\"design:returntype\", void 0)\r\n], hex_grid_HexGrid.prototype, \"dontFollowHorribleHTML5Spec\", null);\r\nhex_grid_decorate([\r\n    childrenAttributeObserver('x', 'y'),\r\n    hex_grid_metadata(\"design:type\", Function),\r\n    hex_grid_metadata(\"design:paramtypes\", [Array]),\r\n    hex_grid_metadata(\"design:returntype\", void 0)\r\n], hex_grid_HexGrid.prototype, \"handleMovement\", null);\r\nhex_grid_decorate([\r\n    eventHandler('mousemove'),\r\n    hex_grid_metadata(\"design:type\", Function),\r\n    hex_grid_metadata(\"design:paramtypes\", [MouseEvent]),\r\n    hex_grid_metadata(\"design:returntype\", void 0)\r\n], hex_grid_HexGrid.prototype, \"moveDraggedItem\", null);\r\nhex_grid_decorate([\r\n    eventHandler('mousedown'),\r\n    hex_grid_metadata(\"design:type\", Function),\r\n    hex_grid_metadata(\"design:paramtypes\", [MouseEvent]),\r\n    hex_grid_metadata(\"design:returntype\", void 0)\r\n], hex_grid_HexGrid.prototype, \"startDraggingItem\", null);\r\nhex_grid_decorate([\r\n    eventHandler('mouseup'),\r\n    hex_grid_metadata(\"design:type\", Function),\r\n    hex_grid_metadata(\"design:paramtypes\", [MouseEvent]),\r\n    hex_grid_metadata(\"design:returntype\", void 0)\r\n], hex_grid_HexGrid.prototype, \"releaseDraggedItem\", null);\r\n\n// EXTERNAL MODULE: ./src/index.scss\nvar src = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/index.ts\n\r\n\r\n\r\n\r\n\r\n\r\ncustomElements.define('hex-grid', hex_grid_HexGrid);\r\ncustomElements.define('hex-tile', HexTile);\r\ncustomElements.define('unit-edible', UnitEdible);\r\ncustomElements.define('unit-player', UnitPlayer);\r\ngame()();\r\n\n\n//# sourceURL=webpack:///./src/index.ts_+_15_modules?")}]);